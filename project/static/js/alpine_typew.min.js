!function(t) { "function" == typeof define && define.amd ? define(t) : t() }((function() { "use strict"; class t { constructor(t, e, s, r) { this.element = t, this.texts = e || [], this.current = 1, this.currentText = "", this.waitTime = s || 2e3, this.showCursor = r || !1, this.cursor = !0 } async start() { if (this.currentText = this.texts[0] || "", this.element.innerHTML = this.prepareText(!0), !window.matchMedia("(prefers-reduced-motion: reduce)").matches) for (this.increment(); ;)await this.swap() } prepareText(t) { return `${this.currentText}${t ? this.getCursor() : ""}${this.getPlaceholder()}` } getCursor() { return this.showCursor ? '<span style="position:relative;"><span style="position:absolute;top:0.05em;bottom:0.05em;border-left:0.05em solid currentColor;"></span></span>' : "" } getPlaceholder() { return '<span style="position:relative;display:inline-block;height:1em;"></span>' } async swap() { await this.wait(this.waitTime), await this.clear(), await this.type(this.nextText()) } increment() { this.current++, this.current > this.texts.length && (this.current = 1) } nextText() { let t = this.texts[this.current - 1]; return this.increment(), t } text() { return this.currentText } length() { return this.text().length } append(t) { return this.currentText += t, this.element.innerHTML = this.prepareText(!0), this.wait(100) } backspace() { return this.currentText = this.text().slice(0, -1), this.element.innerHTML = this.prepareText(!0), this.wait(100) } async clear() { for (; this.length();)await this.backspace() } async type(t) { for (; t.length;)await this.append(t[0]), t = t.substring(1) } async wait(t) { this.cursor = !0; const e = setInterval((() => { this.cursor = !this.cursor, this.cursor ? this.element.innerHTML = this.prepareText(!0) : this.element.innerHTML = this.prepareText(!1) }), 530); return new Promise((s => { setTimeout((() => { clearInterval(e), s() }), t) })) } } document.addEventListener("alpine:init", (() => { window.Alpine.directive("typewriter", ((e, { expression: s, modifiers: r }, { evaluate: i }) => { const n = i(s), a = r.filter((t => t.match(/^\d+m?s$/))).pop(); let h = null; a && (h = a.endsWith("ms") ? parseInt(a.match(/^(\d+)/)[1]) : 1e3 * parseInt(a.match(/^(\d+)s/)[1])); const c = r.includes("cursor"); new t(e, n, h, c).start().then() })) })) }));
//# sourceMappingURL=alpine-typewriter.min.js.map

